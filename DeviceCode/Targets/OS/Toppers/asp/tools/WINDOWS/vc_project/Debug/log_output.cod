; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1 

	TITLE	E:\netmf-interpreter3\DeviceCode\Targets\OS\Toppers\asp\library\log_output.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
_raddec	DB	'0123456789', 00H
	ORG $+1
_radhex	DB	'0123456789abcdef', 00H
	ORG $+3
_radHEX	DB	'0123456789ABCDEF', 00H
CONST	ENDS
_DATA	SEGMENT
$SG3078	DB	'%d messages are lost.', 00H
	ORG $+2
$SG3068	DB	'%s:%u: Assertion `%s'' failed.', 00H
_DATA	ENDS
PUBLIC	_syslog_printf
PUBLIC	_syslog_print
PUBLIC	_syslog_lostmsg
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\netmf-interpreter3\devicecode\targets\os\toppers\asp\library\log_output.c
_TEXT	SEGMENT
tv82 = -36						; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_buf$ = -20						; size = 11
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
_radix$ = 12						; size = 4
_radchar$ = 16						; size = 4
_width$ = 20						; size = 4
_minus$ = 24						; size = 4
_padzero$ = 28						; size = 4
_putc$ = 32						; size = 4
_convert PROC

; 43   :  *		システムログのフォーマット出力

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00012	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00015	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00018	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00021	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00024	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002c	33 c5		 xor	 eax, ebp
  0002e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 44   :  */
; 45   : 
; 46   : #include <t_stddef.h>
; 47   : #include <t_syslog.h>

  00031	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN12@convert:

; 48   : #include <log_output.h>
; 49   : 

  00038	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
  0003b	33 d2		 xor	 edx, edx
  0003d	f7 75 0c	 div	 DWORD PTR _radix$[ebp]
  00040	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _radchar$[ebp]
  00046	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  00049	88 54 05 ec	 mov	 BYTE PTR _buf$[ebp+eax], dl
  0004d	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax

; 50   : /*

  00056	8b 45 08	 mov	 eax, DWORD PTR _val$[ebp]
  00059	33 d2		 xor	 edx, edx
  0005b	f7 75 0c	 div	 DWORD PTR _radix$[ebp]
  0005e	89 45 08	 mov	 DWORD PTR _val$[ebp], eax

; 51   :  *  数値を文字列に変換

  00061	83 7d e4 0b	 cmp	 DWORD PTR _i$[ebp], 11	; 0000000bH
  00065	73 06		 jae	 SHORT $LN10@convert
  00067	83 7d 08 00	 cmp	 DWORD PTR _val$[ebp], 0
  0006b	75 cb		 jne	 SHORT $LN12@convert
$LN10@convert:

; 52   :  */
; 53   : #define CONVERT_BUFLEN	((sizeof(uintptr_t) * CHAR_BIT + 2) / 3)

  0006d	83 7d 18 00	 cmp	 DWORD PTR _minus$[ebp], 0
  00071	74 0f		 je	 SHORT $LN8@convert
  00073	83 7d 14 00	 cmp	 DWORD PTR _width$[ebp], 0
  00077	76 09		 jbe	 SHORT $LN8@convert

; 54   : 										/* uintptr_t型の数値の最大文字数 */

  00079	8b 4d 14	 mov	 ecx, DWORD PTR _width$[ebp]
  0007c	83 e9 01	 sub	 ecx, 1
  0007f	89 4d 14	 mov	 DWORD PTR _width$[ebp], ecx
$LN8@convert:

; 55   : static void
; 56   : convert(uintptr_t val, uint_t radix, const char *radchar,

  00082	83 7d 18 00	 cmp	 DWORD PTR _minus$[ebp], 0
  00086	74 17		 je	 SHORT $LN7@convert
  00088	83 7d 1c 00	 cmp	 DWORD PTR _padzero$[ebp], 0
  0008c	74 11		 je	 SHORT $LN7@convert

; 57   : 			uint_t width, bool_t minus, bool_t padzero, void (*putc)(char))

  0008e	8b f4		 mov	 esi, esp
  00090	6a 2d		 push	 45			; 0000002dH
  00092	ff 55 20	 call	 DWORD PTR _putc$[ebp]
  00095	83 c4 04	 add	 esp, 4
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN7@convert:

; 58   : {
; 59   : 	char	buf[CONVERT_BUFLEN];

  0009f	8b 55 e4	 mov	 edx, DWORD PTR _i$[ebp]
  000a2	89 55 e0	 mov	 DWORD PTR _j$[ebp], edx
  000a5	eb 09		 jmp	 SHORT $LN6@convert
$LN5@convert:
  000a7	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000aa	83 c0 01	 add	 eax, 1
  000ad	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax
$LN6@convert:
  000b0	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000b3	3b 4d 14	 cmp	 ecx, DWORD PTR _width$[ebp]
  000b6	73 2c		 jae	 SHORT $LN4@convert

; 60   : 	uint_t	i, j;

  000b8	83 7d 1c 00	 cmp	 DWORD PTR _padzero$[ebp], 0
  000bc	74 09		 je	 SHORT $LN15@convert
  000be	c7 45 dc 30 00
	00 00		 mov	 DWORD PTR tv82[ebp], 48	; 00000030H
  000c5	eb 07		 jmp	 SHORT $LN16@convert
$LN15@convert:
  000c7	c7 45 dc 20 00
	00 00		 mov	 DWORD PTR tv82[ebp], 32	; 00000020H
$LN16@convert:
  000ce	8b f4		 mov	 esi, esp
  000d0	0f b6 55 dc	 movzx	 edx, BYTE PTR tv82[ebp]
  000d4	52		 push	 edx
  000d5	ff 55 20	 call	 DWORD PTR _putc$[ebp]
  000d8	83 c4 04	 add	 esp, 4
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 61   : 

  000e2	eb c3		 jmp	 SHORT $LN5@convert
$LN4@convert:

; 62   : 	i = 0U;

  000e4	83 7d 18 00	 cmp	 DWORD PTR _minus$[ebp], 0
  000e8	74 17		 je	 SHORT $LN2@convert
  000ea	83 7d 1c 00	 cmp	 DWORD PTR _padzero$[ebp], 0
  000ee	75 11		 jne	 SHORT $LN2@convert

; 63   : 	do {

  000f0	8b f4		 mov	 esi, esp
  000f2	6a 2d		 push	 45			; 0000002dH
  000f4	ff 55 20	 call	 DWORD PTR _putc$[ebp]
  000f7	83 c4 04	 add	 esp, 4
  000fa	3b f4		 cmp	 esi, esp
  000fc	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@convert:

; 64   : 		buf[i++] = radchar[val % radix];
; 65   : 		val /= radix;

  00101	83 7d e4 00	 cmp	 DWORD PTR _i$[ebp], 0
  00105	76 23		 jbe	 SHORT $LN13@convert

; 66   : 	} while (i < CONVERT_BUFLEN && val != 0);

  00107	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  0010a	83 e8 01	 sub	 eax, 1
  0010d	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
  00110	8b f4		 mov	 esi, esp
  00112	8b 4d e4	 mov	 ecx, DWORD PTR _i$[ebp]
  00115	0f b6 54 0d ec	 movzx	 edx, BYTE PTR _buf$[ebp+ecx]
  0011a	52		 push	 edx
  0011b	ff 55 20	 call	 DWORD PTR _putc$[ebp]
  0011e	83 c4 04	 add	 esp, 4
  00121	3b f4		 cmp	 esi, esp
  00123	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 67   : 

  00128	eb d7		 jmp	 SHORT $LN2@convert
$LN13@convert:

; 68   : 	if (minus && width > 0) {

  0012a	52		 push	 edx
  0012b	8b cd		 mov	 ecx, ebp
  0012d	50		 push	 eax
  0012e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@convert
  00134	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00139	58		 pop	 eax
  0013a	5a		 pop	 edx
  0013b	5e		 pop	 esi
  0013c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013f	33 cd		 xor	 ecx, ebp
  00141	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00146	83 c4 24	 add	 esp, 36			; 00000024H
  00149	3b ec		 cmp	 ebp, esp
  0014b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c3		 ret	 0
$LN19@convert:
  00154	01 00 00 00	 DD	 1
  00158	00 00 00 00	 DD	 $LN18@convert
$LN18@convert:
  0015c	ec ff ff ff	 DD	 -20			; ffffffecH
  00160	0b 00 00 00	 DD	 11			; 0000000bH
  00164	00 00 00 00	 DD	 $LN17@convert
$LN17@convert:
  00168	62		 DB	 98			; 00000062H
  00169	75		 DB	 117			; 00000075H
  0016a	66		 DB	 102			; 00000066H
  0016b	00		 DB	 0
_convert ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\netmf-interpreter3\devicecode\targets\os\toppers\asp\library\log_output.c
_TEXT	SEGMENT
_lostinfo$ = -8						; size = 4
_lostlog$ = 8						; size = 4
_putc$ = 12						; size = 4
_syslog_lostmsg PROC

; 175  : 								&(p_syslog->loginfo[1]), putc);

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 176  : 		break;
; 177  : 	case LOG_TYPE_ASSERT:
; 178  : 		syslog_printf("%s:%u: Assertion `%s' failed.",

  0001c	b8 04 00 00 00	 mov	 eax, 4
  00021	6b c8 00	 imul	 ecx, eax, 0
  00024	8b 55 08	 mov	 edx, DWORD PTR _lostlog$[ebp]
  00027	89 54 0d f8	 mov	 DWORD PTR _lostinfo$[ebp+ecx], edx

; 179  : 								&(p_syslog->loginfo[0]), putc);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _putc$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d f8	 lea	 ecx, DWORD PTR _lostinfo$[ebp]
  00032	51		 push	 ecx
  00033	68 00 00 00 00	 push	 OFFSET $SG3078
  00038	e8 00 00 00 00	 call	 _syslog_printf
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 180  : 		break;

  00040	8b f4		 mov	 esi, esp
  00042	6a 0a		 push	 10			; 0000000aH
  00044	ff 55 0c	 call	 DWORD PTR _putc$[ebp]
  00047	83 c4 04	 add	 esp, 4
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 181  : 	default:

  00051	52		 push	 edx
  00052	8b cd		 mov	 ecx, ebp
  00054	50		 push	 eax
  00055	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@syslog_los
  0005b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00060	58		 pop	 eax
  00061	5a		 pop	 edx
  00062	5e		 pop	 esi
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
  00071	8d 49 00	 npad	 3
$LN5@syslog_los:
  00074	01 00 00 00	 DD	 1
  00078	00 00 00 00	 DD	 $LN4@syslog_los
$LN4@syslog_los:
  0007c	f8 ff ff ff	 DD	 -8			; fffffff8H
  00080	04 00 00 00	 DD	 4
  00084	00 00 00 00	 DD	 $LN3@syslog_los
$LN3@syslog_los:
  00088	6c		 DB	 108			; 0000006cH
  00089	6f		 DB	 111			; 0000006fH
  0008a	73		 DB	 115			; 00000073H
  0008b	74		 DB	 116			; 00000074H
  0008c	69		 DB	 105			; 00000069H
  0008d	6e		 DB	 110			; 0000006eH
  0008e	66		 DB	 102			; 00000066H
  0008f	6f		 DB	 111			; 0000006fH
  00090	00		 DB	 0
_syslog_lostmsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\netmf-interpreter3\devicecode\targets\os\toppers\asp\library\log_output.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_p_syslog$ = 8						; size = 4
_putc$ = 12						; size = 4
_syslog_print PROC

; 154  : 		case '%':

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 155  : 			(*putc)('%');

  0000b	8b 45 08	 mov	 eax, DWORD PTR _p_syslog$[ebp]
  0000e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00010	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
  00013	83 7d fc 01	 cmp	 DWORD PTR tv65[ebp], 1
  00017	74 08		 je	 SHORT $LN3@syslog_pri
  00019	83 7d fc 02	 cmp	 DWORD PTR tv65[ebp], 2
  0001d	74 30		 je	 SHORT $LN2@syslog_pri
  0001f	eb 4f		 jmp	 SHORT $LN6@syslog_pri
$LN3@syslog_pri:

; 156  : 			break;
; 157  : 		case '\0':
; 158  : 			format--;

  00021	8b 55 0c	 mov	 edx, DWORD PTR _putc$[ebp]
  00024	52		 push	 edx
  00025	b8 04 00 00 00	 mov	 eax, 4
  0002a	c1 e0 00	 shl	 eax, 0
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _p_syslog$[ebp]
  00030	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00034	52		 push	 edx
  00035	b8 04 00 00 00	 mov	 eax, 4
  0003a	6b c8 00	 imul	 ecx, eax, 0
  0003d	8b 55 08	 mov	 edx, DWORD PTR _p_syslog$[ebp]
  00040	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _syslog_printf
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 159  : 			break;

  0004d	eb 21		 jmp	 SHORT $LN6@syslog_pri
$LN2@syslog_pri:

; 160  : 		default:
; 161  : 			break;
; 162  : 		}

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _putc$[ebp]
  00052	51		 push	 ecx
  00053	ba 04 00 00 00	 mov	 edx, 4
  00058	6b c2 00	 imul	 eax, edx, 0
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _p_syslog$[ebp]
  0005e	8d 54 01 08	 lea	 edx, DWORD PTR [ecx+eax+8]
  00062	52		 push	 edx
  00063	68 00 00 00 00	 push	 OFFSET $SG3068
  00068	e8 00 00 00 00	 call	 _syslog_printf
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@syslog_pri:

; 163  : 	}
; 164  : }
; 165  : 
; 166  : /*
; 167  :  *  ログ情報の出力
; 168  :  */
; 169  : void

  00070	83 c4 04	 add	 esp, 4
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_syslog_print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File e:\netmf-interpreter3\devicecode\targets\os\toppers\asp\library\log_output.c
_TEXT	SEGMENT
tv175 = -52						; size = 4
tv174 = -48						; size = 4
tv168 = -41						; size = 1
tv93 = -40						; size = 4
tv77 = -36						; size = 4
tv76 = -32						; size = 4
tv68 = -28						; size = 4
tv67 = -24						; size = 4
_str$ = -20						; size = 4
_val$ = -16						; size = 4
_padzero$ = -12						; size = 4
_width$ = -8						; size = 4
_c$ = -1						; size = 1
_format$ = 8						; size = 4
_p_args$ = 12						; size = 4
_putc$ = 16						; size = 4
_syslog_printf PROC

; 78   : 		(*putc)('-');

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000b	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
$LN22@syslog_pri:

; 79   : 	}
; 80   : 	while (i > 0U) {
; 81   : 		(*putc)(buf[--i]);
; 82   : 	}
; 83   : }
; 84   : 
; 85   : /*

  00017	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  0001a	8a 08		 mov	 cl, BYTE PTR [eax]
  0001c	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl
  0001f	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  00023	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  00026	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 08	 mov	 DWORD PTR _format$[ebp], eax
  0002f	83 7d e8 00	 cmp	 DWORD PTR tv67[ebp], 0
  00033	74 09		 je	 SHORT $LN25@syslog_pri
  00035	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0003c	eb 07		 jmp	 SHORT $LN26@syslog_pri
$LN25@syslog_pri:
  0003e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN26@syslog_pri:
  00045	83 7d e4 00	 cmp	 DWORD PTR tv68[ebp], 0
  00049	0f 84 95 02 00
	00		 je	 $LN23@syslog_pri

; 86   :  *  文字列整形出力

  0004f	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  00053	83 f9 25	 cmp	 ecx, 37			; 00000025H
  00056	74 16		 je	 SHORT $LN20@syslog_pri

; 87   :  */

  00058	8b f4		 mov	 esi, esp
  0005a	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  0005e	52		 push	 edx
  0005f	ff 55 10	 call	 DWORD PTR _putc$[ebp]
  00062	83 c4 04	 add	 esp, 4
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 88   : static const char raddec[] = "0123456789";

  0006c	eb a9		 jmp	 SHORT $LN22@syslog_pri
$LN20@syslog_pri:

; 89   : static const char radhex[] = "0123456789abcdef";
; 90   : static const char radHEX[] = "0123456789ABCDEF";
; 91   : 

  0006e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _width$[ebp], 0

; 92   : void

  00075	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _padzero$[ebp], 0

; 93   : syslog_printf(const char *format, const intptr_t *p_args, void (*putc)(char))

  0007c	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  0007f	8a 08		 mov	 cl, BYTE PTR [eax]
  00081	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl
  00084	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  00088	89 55 e0	 mov	 DWORD PTR tv76[ebp], edx
  0008b	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  0008e	83 c0 01	 add	 eax, 1
  00091	89 45 08	 mov	 DWORD PTR _format$[ebp], eax
  00094	83 7d e0 30	 cmp	 DWORD PTR tv76[ebp], 48	; 00000030H
  00098	75 09		 jne	 SHORT $LN27@syslog_pri
  0009a	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  000a1	eb 07		 jmp	 SHORT $LN28@syslog_pri
$LN27@syslog_pri:
  000a3	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN28@syslog_pri:
  000aa	83 7d dc 00	 cmp	 DWORD PTR tv77[ebp], 0
  000ae	74 18		 je	 SHORT $LN18@syslog_pri

; 94   : {

  000b0	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _padzero$[ebp], 1

; 95   : 	char		c;

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _format$[ebp]
  000ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bc	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl
  000bf	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  000c2	83 c0 01	 add	 eax, 1
  000c5	89 45 08	 mov	 DWORD PTR _format$[ebp], eax
$LN18@syslog_pri:

; 96   : 	uint_t		width;
; 97   : 	bool_t		padzero;

  000c8	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  000cc	83 f9 30	 cmp	 ecx, 48			; 00000030H
  000cf	7c 2b		 jl	 SHORT $LN17@syslog_pri
  000d1	0f be 55 ff	 movsx	 edx, BYTE PTR _c$[ebp]
  000d5	83 fa 39	 cmp	 edx, 57			; 00000039H
  000d8	7f 22		 jg	 SHORT $LN17@syslog_pri

; 98   : 	intptr_t	val;

  000da	6b 45 f8 0a	 imul	 eax, DWORD PTR _width$[ebp], 10
  000de	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  000e2	8d 54 08 d0	 lea	 edx, DWORD PTR [eax+ecx-48]
  000e6	89 55 f8	 mov	 DWORD PTR _width$[ebp], edx

; 99   : 	const char	*str;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  000ec	8a 08		 mov	 cl, BYTE PTR [eax]
  000ee	88 4d ff	 mov	 BYTE PTR _c$[ebp], cl
  000f1	8b 55 08	 mov	 edx, DWORD PTR _format$[ebp]
  000f4	83 c2 01	 add	 edx, 1
  000f7	89 55 08	 mov	 DWORD PTR _format$[ebp], edx

; 100  : 

  000fa	eb cc		 jmp	 SHORT $LN18@syslog_pri
$LN17@syslog_pri:

; 101  : 	while ((c = *format++) != '\0') {

  000fc	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00100	83 f8 6c	 cmp	 eax, 108		; 0000006cH
  00103	75 11		 jne	 SHORT $LN16@syslog_pri

; 102  : 		if (c != '%') {

  00105	8b 4d 08	 mov	 ecx, DWORD PTR _format$[ebp]
  00108	8a 11		 mov	 dl, BYTE PTR [ecx]
  0010a	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl
  0010d	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 08	 mov	 DWORD PTR _format$[ebp], eax
$LN16@syslog_pri:

; 103  : 			(*putc)(c);
; 104  : 			continue;

  00116	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  0011a	89 4d d8	 mov	 DWORD PTR tv93[ebp], ecx
  0011d	83 7d d8 78	 cmp	 DWORD PTR tv93[ebp], 120 ; 00000078H
  00121	0f 87 b8 01 00
	00		 ja	 $LN14@syslog_pri
  00127	8b 55 d8	 mov	 edx, DWORD PTR tv93[ebp]
  0012a	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN32@syslog_pri[edx]
  00131	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN33@syslog_pri[eax*4]
$LN13@syslog_pri:

; 105  : 		}
; 106  : 

  00138	8b 4d 0c	 mov	 ecx, DWORD PTR _p_args$[ebp]
  0013b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013d	89 55 f0	 mov	 DWORD PTR _val$[ebp], edx
  00140	8b 45 0c	 mov	 eax, DWORD PTR _p_args$[ebp]
  00143	83 c0 04	 add	 eax, 4
  00146	89 45 0c	 mov	 DWORD PTR _p_args$[ebp], eax

; 107  : 		width = 0U;

  00149	83 7d f0 00	 cmp	 DWORD PTR _val$[ebp], 0
  0014d	7c 23		 jl	 SHORT $LN12@syslog_pri

; 108  : 		padzero = false;
; 109  : 		if ((c = *format++) == '0') {

  0014f	8b 4d 10	 mov	 ecx, DWORD PTR _putc$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 f4	 mov	 edx, DWORD PTR _padzero$[ebp]
  00156	52		 push	 edx
  00157	6a 00		 push	 0
  00159	8b 45 f8	 mov	 eax, DWORD PTR _width$[ebp]
  0015c	50		 push	 eax
  0015d	68 00 00 00 00	 push	 OFFSET _raddec
  00162	6a 0a		 push	 10			; 0000000aH
  00164	8b 4d f0	 mov	 ecx, DWORD PTR _val$[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 _convert
  0016d	83 c4 1c	 add	 esp, 28			; 0000001cH

; 110  : 			padzero = true;
; 111  : 			c = *format++;

  00170	eb 23		 jmp	 SHORT $LN11@syslog_pri
$LN12@syslog_pri:

; 112  : 		}
; 113  : 		while ('0' <= c && c <= '9') {

  00172	8b 55 10	 mov	 edx, DWORD PTR _putc$[ebp]
  00175	52		 push	 edx
  00176	8b 45 f4	 mov	 eax, DWORD PTR _padzero$[ebp]
  00179	50		 push	 eax
  0017a	6a 01		 push	 1
  0017c	8b 4d f8	 mov	 ecx, DWORD PTR _width$[ebp]
  0017f	51		 push	 ecx
  00180	68 00 00 00 00	 push	 OFFSET _raddec
  00185	6a 0a		 push	 10			; 0000000aH
  00187	8b 55 f0	 mov	 edx, DWORD PTR _val$[ebp]
  0018a	f7 da		 neg	 edx
  0018c	52		 push	 edx
  0018d	e8 00 00 00 00	 call	 _convert
  00192	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN11@syslog_pri:

; 114  : 			width = width * 10U + c - '0';
; 115  : 			c = *format++;

  00195	e9 45 01 00 00	 jmp	 $LN14@syslog_pri
$LN10@syslog_pri:

; 116  : 		}
; 117  : 		if (c == 'l') {

  0019a	8b 45 0c	 mov	 eax, DWORD PTR _p_args$[ebp]
  0019d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019f	89 4d f0	 mov	 DWORD PTR _val$[ebp], ecx
  001a2	8b 55 0c	 mov	 edx, DWORD PTR _p_args$[ebp]
  001a5	83 c2 04	 add	 edx, 4
  001a8	89 55 0c	 mov	 DWORD PTR _p_args$[ebp], edx

; 118  : 			c = *format++;

  001ab	8b 45 10	 mov	 eax, DWORD PTR _putc$[ebp]
  001ae	50		 push	 eax
  001af	8b 4d f4	 mov	 ecx, DWORD PTR _padzero$[ebp]
  001b2	51		 push	 ecx
  001b3	6a 00		 push	 0
  001b5	8b 55 f8	 mov	 edx, DWORD PTR _width$[ebp]
  001b8	52		 push	 edx
  001b9	68 00 00 00 00	 push	 OFFSET _raddec
  001be	6a 0a		 push	 10			; 0000000aH
  001c0	8b 45 f0	 mov	 eax, DWORD PTR _val$[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _convert
  001c9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 119  : 		}

  001cc	e9 0e 01 00 00	 jmp	 $LN14@syslog_pri
$LN9@syslog_pri:

; 120  : 		switch (c) {
; 121  : 		case 'd':
; 122  : 			val = (intptr_t)(*p_args++);

  001d1	8b 4d 0c	 mov	 ecx, DWORD PTR _p_args$[ebp]
  001d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d6	89 55 f0	 mov	 DWORD PTR _val$[ebp], edx
  001d9	8b 45 0c	 mov	 eax, DWORD PTR _p_args$[ebp]
  001dc	83 c0 04	 add	 eax, 4
  001df	89 45 0c	 mov	 DWORD PTR _p_args$[ebp], eax

; 123  : 			if (val >= 0) {

  001e2	8b 4d 10	 mov	 ecx, DWORD PTR _putc$[ebp]
  001e5	51		 push	 ecx
  001e6	8b 55 f4	 mov	 edx, DWORD PTR _padzero$[ebp]
  001e9	52		 push	 edx
  001ea	6a 00		 push	 0
  001ec	8b 45 f8	 mov	 eax, DWORD PTR _width$[ebp]
  001ef	50		 push	 eax
  001f0	68 00 00 00 00	 push	 OFFSET _radhex
  001f5	6a 10		 push	 16			; 00000010H
  001f7	8b 4d f0	 mov	 ecx, DWORD PTR _val$[ebp]
  001fa	51		 push	 ecx
  001fb	e8 00 00 00 00	 call	 _convert
  00200	83 c4 1c	 add	 esp, 28			; 0000001cH

; 124  : 				convert((uintptr_t) val, 10U, raddec,

  00203	e9 d7 00 00 00	 jmp	 $LN14@syslog_pri
$LN8@syslog_pri:

; 125  : 										width, false, padzero, putc);
; 126  : 			}

  00208	8b 55 0c	 mov	 edx, DWORD PTR _p_args$[ebp]
  0020b	8b 02		 mov	 eax, DWORD PTR [edx]
  0020d	89 45 f0	 mov	 DWORD PTR _val$[ebp], eax
  00210	8b 4d 0c	 mov	 ecx, DWORD PTR _p_args$[ebp]
  00213	83 c1 04	 add	 ecx, 4
  00216	89 4d 0c	 mov	 DWORD PTR _p_args$[ebp], ecx

; 127  : 			else {

  00219	8b 55 10	 mov	 edx, DWORD PTR _putc$[ebp]
  0021c	52		 push	 edx
  0021d	8b 45 f4	 mov	 eax, DWORD PTR _padzero$[ebp]
  00220	50		 push	 eax
  00221	6a 00		 push	 0
  00223	8b 4d f8	 mov	 ecx, DWORD PTR _width$[ebp]
  00226	51		 push	 ecx
  00227	68 00 00 00 00	 push	 OFFSET _radHEX
  0022c	6a 10		 push	 16			; 00000010H
  0022e	8b 55 f0	 mov	 edx, DWORD PTR _val$[ebp]
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 _convert
  00237	83 c4 1c	 add	 esp, 28			; 0000001cH

; 128  : 				convert((uintptr_t)(-val), 10U, raddec,

  0023a	e9 a0 00 00 00	 jmp	 $LN14@syslog_pri
$LN7@syslog_pri:

; 129  : 										width, true, padzero, putc);
; 130  : 			}

  0023f	8b 45 0c	 mov	 eax, DWORD PTR _p_args$[ebp]
  00242	8a 08		 mov	 cl, BYTE PTR [eax]
  00244	88 4d d7	 mov	 BYTE PTR tv168[ebp], cl
  00247	8b 55 0c	 mov	 edx, DWORD PTR _p_args$[ebp]
  0024a	83 c2 04	 add	 edx, 4
  0024d	89 55 0c	 mov	 DWORD PTR _p_args$[ebp], edx
  00250	8b f4		 mov	 esi, esp
  00252	0f b6 45 d7	 movzx	 eax, BYTE PTR tv168[ebp]
  00256	50		 push	 eax
  00257	ff 55 10	 call	 DWORD PTR _putc$[ebp]
  0025a	83 c4 04	 add	 esp, 4
  0025d	3b f4		 cmp	 esi, esp
  0025f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 131  : 			break;

  00264	eb 79		 jmp	 SHORT $LN14@syslog_pri
$LN6@syslog_pri:

; 132  : 		case 'u':
; 133  : 			val = (intptr_t)(*p_args++);

  00266	8b 4d 0c	 mov	 ecx, DWORD PTR _p_args$[ebp]
  00269	8b 11		 mov	 edx, DWORD PTR [ecx]
  0026b	89 55 ec	 mov	 DWORD PTR _str$[ebp], edx
  0026e	8b 45 0c	 mov	 eax, DWORD PTR _p_args$[ebp]
  00271	83 c0 04	 add	 eax, 4
  00274	89 45 0c	 mov	 DWORD PTR _p_args$[ebp], eax
$LN5@syslog_pri:

; 134  : 			convert((uintptr_t) val, 10U, raddec, width, false, padzero, putc);

  00277	8b 4d ec	 mov	 ecx, DWORD PTR _str$[ebp]
  0027a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0027c	88 55 ff	 mov	 BYTE PTR _c$[ebp], dl
  0027f	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00283	89 45 d0	 mov	 DWORD PTR tv174[ebp], eax
  00286	8b 4d ec	 mov	 ecx, DWORD PTR _str$[ebp]
  00289	83 c1 01	 add	 ecx, 1
  0028c	89 4d ec	 mov	 DWORD PTR _str$[ebp], ecx
  0028f	83 7d d0 00	 cmp	 DWORD PTR tv174[ebp], 0
  00293	74 09		 je	 SHORT $LN29@syslog_pri
  00295	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv175[ebp], 1
  0029c	eb 07		 jmp	 SHORT $LN30@syslog_pri
$LN29@syslog_pri:
  0029e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv175[ebp], 0
$LN30@syslog_pri:
  002a5	83 7d cc 00	 cmp	 DWORD PTR tv175[ebp], 0
  002a9	74 16		 je	 SHORT $LN4@syslog_pri

; 135  : 			break;

  002ab	8b f4		 mov	 esi, esp
  002ad	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  002b1	52		 push	 edx
  002b2	ff 55 10	 call	 DWORD PTR _putc$[ebp]
  002b5	83 c4 04	 add	 esp, 4
  002b8	3b f4		 cmp	 esi, esp
  002ba	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 136  : 		case 'x':

  002bf	eb b6		 jmp	 SHORT $LN5@syslog_pri
$LN4@syslog_pri:

; 137  : 		case 'p':

  002c1	eb 1c		 jmp	 SHORT $LN14@syslog_pri
$LN3@syslog_pri:

; 138  : 			val = (intptr_t)(*p_args++);
; 139  : 			convert((uintptr_t) val, 16U, radhex, width, false, padzero, putc);

  002c3	8b f4		 mov	 esi, esp
  002c5	6a 25		 push	 37			; 00000025H
  002c7	ff 55 10	 call	 DWORD PTR _putc$[ebp]
  002ca	83 c4 04	 add	 esp, 4
  002cd	3b f4		 cmp	 esi, esp
  002cf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 140  : 			break;

  002d4	eb 09		 jmp	 SHORT $LN14@syslog_pri
$LN2@syslog_pri:

; 141  : 		case 'X':
; 142  : 			val = (intptr_t)(*p_args++);

  002d6	8b 45 08	 mov	 eax, DWORD PTR _format$[ebp]
  002d9	83 e8 01	 sub	 eax, 1
  002dc	89 45 08	 mov	 DWORD PTR _format$[ebp], eax
$LN14@syslog_pri:

; 143  : 			convert((uintptr_t) val, 16U, radHEX, width, false, padzero, putc);
; 144  : 			break;
; 145  : 		case 'c':
; 146  : 			(*putc)((char)(intptr_t)(*p_args++));
; 147  : 			break;

  002df	e9 33 fd ff ff	 jmp	 $LN22@syslog_pri
$LN23@syslog_pri:

; 148  : 		case 's':

  002e4	5f		 pop	 edi
  002e5	5e		 pop	 esi
  002e6	83 c4 34	 add	 esp, 52			; 00000034H
  002e9	3b ec		 cmp	 ebp, esp
  002eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002f0	8b e5		 mov	 esp, ebp
  002f2	5d		 pop	 ebp
  002f3	c3		 ret	 0
$LN33@syslog_pri:
  002f4	00 00 00 00	 DD	 $LN2@syslog_pri
  002f8	00 00 00 00	 DD	 $LN3@syslog_pri
  002fc	00 00 00 00	 DD	 $LN8@syslog_pri
  00300	00 00 00 00	 DD	 $LN7@syslog_pri
  00304	00 00 00 00	 DD	 $LN13@syslog_pri
  00308	00 00 00 00	 DD	 $LN9@syslog_pri
  0030c	00 00 00 00	 DD	 $LN6@syslog_pri
  00310	00 00 00 00	 DD	 $LN10@syslog_pri
  00314	00 00 00 00	 DD	 $LN14@syslog_pri
$LN32@syslog_pri:
  00318	00		 DB	 0
  00319	08		 DB	 8
  0031a	08		 DB	 8
  0031b	08		 DB	 8
  0031c	08		 DB	 8
  0031d	08		 DB	 8
  0031e	08		 DB	 8
  0031f	08		 DB	 8
  00320	08		 DB	 8
  00321	08		 DB	 8
  00322	08		 DB	 8
  00323	08		 DB	 8
  00324	08		 DB	 8
  00325	08		 DB	 8
  00326	08		 DB	 8
  00327	08		 DB	 8
  00328	08		 DB	 8
  00329	08		 DB	 8
  0032a	08		 DB	 8
  0032b	08		 DB	 8
  0032c	08		 DB	 8
  0032d	08		 DB	 8
  0032e	08		 DB	 8
  0032f	08		 DB	 8
  00330	08		 DB	 8
  00331	08		 DB	 8
  00332	08		 DB	 8
  00333	08		 DB	 8
  00334	08		 DB	 8
  00335	08		 DB	 8
  00336	08		 DB	 8
  00337	08		 DB	 8
  00338	08		 DB	 8
  00339	08		 DB	 8
  0033a	08		 DB	 8
  0033b	08		 DB	 8
  0033c	08		 DB	 8
  0033d	01		 DB	 1
  0033e	08		 DB	 8
  0033f	08		 DB	 8
  00340	08		 DB	 8
  00341	08		 DB	 8
  00342	08		 DB	 8
  00343	08		 DB	 8
  00344	08		 DB	 8
  00345	08		 DB	 8
  00346	08		 DB	 8
  00347	08		 DB	 8
  00348	08		 DB	 8
  00349	08		 DB	 8
  0034a	08		 DB	 8
  0034b	08		 DB	 8
  0034c	08		 DB	 8
  0034d	08		 DB	 8
  0034e	08		 DB	 8
  0034f	08		 DB	 8
  00350	08		 DB	 8
  00351	08		 DB	 8
  00352	08		 DB	 8
  00353	08		 DB	 8
  00354	08		 DB	 8
  00355	08		 DB	 8
  00356	08		 DB	 8
  00357	08		 DB	 8
  00358	08		 DB	 8
  00359	08		 DB	 8
  0035a	08		 DB	 8
  0035b	08		 DB	 8
  0035c	08		 DB	 8
  0035d	08		 DB	 8
  0035e	08		 DB	 8
  0035f	08		 DB	 8
  00360	08		 DB	 8
  00361	08		 DB	 8
  00362	08		 DB	 8
  00363	08		 DB	 8
  00364	08		 DB	 8
  00365	08		 DB	 8
  00366	08		 DB	 8
  00367	08		 DB	 8
  00368	08		 DB	 8
  00369	08		 DB	 8
  0036a	08		 DB	 8
  0036b	08		 DB	 8
  0036c	08		 DB	 8
  0036d	08		 DB	 8
  0036e	08		 DB	 8
  0036f	08		 DB	 8
  00370	02		 DB	 2
  00371	08		 DB	 8
  00372	08		 DB	 8
  00373	08		 DB	 8
  00374	08		 DB	 8
  00375	08		 DB	 8
  00376	08		 DB	 8
  00377	08		 DB	 8
  00378	08		 DB	 8
  00379	08		 DB	 8
  0037a	08		 DB	 8
  0037b	03		 DB	 3
  0037c	04		 DB	 4
  0037d	08		 DB	 8
  0037e	08		 DB	 8
  0037f	08		 DB	 8
  00380	08		 DB	 8
  00381	08		 DB	 8
  00382	08		 DB	 8
  00383	08		 DB	 8
  00384	08		 DB	 8
  00385	08		 DB	 8
  00386	08		 DB	 8
  00387	08		 DB	 8
  00388	05		 DB	 5
  00389	08		 DB	 8
  0038a	08		 DB	 8
  0038b	06		 DB	 6
  0038c	08		 DB	 8
  0038d	07		 DB	 7
  0038e	08		 DB	 8
  0038f	08		 DB	 8
  00390	05		 DB	 5
_syslog_printf ENDP
_TEXT	ENDS
END
