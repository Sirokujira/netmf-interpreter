実体とシミュレーションのシーケンス

シミュレーション側 : MinMFWin32 

    HAL_Initialize( );

    // perform second stage of settings processing
    // this executes additional actions that require
    // HAL_Initialize() to complete first. (i.e. loading
    // PE and DAT files and saving them, along with other
    // config data to the blockstorage 'FLASH' )
    hr = g_CommandLineParams.ProcessCommandLineSettings( );
    if( FAILED( hr ) )
        return FALSE;

    // don't initialize network until AFTER processing
    // command line args that can modify it's startup
    if( !g_CommandLineParams.m_fNoNetwork )
        Network_Initialize();

    clrSet.MaxContextSwitches = 50;
    clrSet.PerformGarbageCollection = g_CommandLineParams.m_fPerformGarbageCollection;
    clrSet.PerformHeapCompaction = g_CommandLineParams.m_fPerformHeapCompaction;
    clrSet.WaitForDebugger = g_CommandLineParams.m_fWaitForDebugger;

#if defined(TINYCLR_TRACE_MEMORY_STATS)
    // force tracing off as it is pretty noisy.
    s_CLR_RT_fTrace_MemoryStats = 0;
#endif

    // Unless noexecute was specified on cmdline, hand off to the CLR core to run the code
    if( !g_CommandLineParams.m_fNoExecuteIL )
        ClrStartup( clrSet );

    HAL_Uninitialize( );
    return 0;

実体側

    HAL_Initialize();

    // シミュレーション の FLASH領域確保みたいなもの？
    // g_CommandLineParams.ProcessCommandLineSettings( );
    UINT8* BaseAddress;
    UINT32 SizeInBytes;

    HeapLocation( BaseAddress,    SizeInBytes );
    memset      ( BaseAddress, 0, SizeInBytes );
    // 

    // the runtime is by default using a watchdog 

    Watchdog_GetSetTimeout ( WATCHDOG_TIMEOUT , TRUE );
    Watchdog_GetSetBehavior( WATCHDOG_BEHAVIOR, TRUE );
    Watchdog_GetSetEnabled ( WATCHDOG_ENABLE, TRUE );

   	// HAL initialization completed.  Interrupts are enabled.  Jump to the Application routine
   	// clrSet のセット + ClrStartup の呼び出し
	ApplicationEntryPoint();

    